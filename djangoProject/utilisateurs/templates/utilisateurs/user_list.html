{% extends 'base.html' %}
{% load static %}

{% block content %}
{% csrf_token %}

<link rel="stylesheet" href="{% static 'styles/user_list.css' %}">

<div class="app-wrapper">
    {% include 'layout/sidebar.html' %}
    <main class="main-content">
        <div class="main-element">
            <header class="header">
                <div class="feed-selector">
                    Messages
                    <i class="fa-solid fa-chevron-down"></i>
                </div>
            </header>

            <div class="user-list" id="user-list">
                {% for user in users %}
                <div class="user-card" data-user-id="{{ user.id }}">
                    <div class="user-info">
                        <div class="user-initial" style="background-color: {% if user.nom_utilisateur|first == 'T' %}#0084ff{% else %}#6c757d{% endif %}">
                            {{ user.nom_utilisateur|first }}
                        </div>
                        <div class="user-details">
                            <span class="username">{{ user.nom_utilisateur }}</span>
                            <div class="message-preview">
                                {% if user.last_message_is_mine %}
                                <span class="message-sender">Vous: </span>
                                {% endif %}
                                <span class="last-message {% if not user.message_read %}unread{% endif %}">
                                    {{ user.last_message|default:"Pas de message" }}
                                </span>
                            </div>
                        </div>
                    </div>
                    <button class="btn-message" data-user-id="{{ user.id }}" data-username="{{ user.nom_utilisateur }}">
                        <i class="fa-regular fa-message"></i>
                    </button>
                </div>
                {% endfor %}
            </div>
        </div>
    </main>
</div>

<div id="chat-dialog" class="chat-dialog">
    <div class="chat-header">
        <div class="chat-header-info">
            <div class="user-initial header-initial">#</div>
            <div class="header-text">
                <span class="chat-title"></span>
                <span class="online-status">En ligne</span>
            </div>
        </div>
        <div class="chat-header-actions">
            <button class="btn-icon minimize-chat">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path d="M19 13H5v-2h14v2z" fill="currentColor"/>
                </svg>
            </button>
            <button class="close-chat">
                ‚úï
            </button>
        </div>
    </div>
    <div class="chat-messages"></div>
    <div class="chat-input-container">
        <div class="chat-input-wrapper">
            <input type="text" placeholder="Aa" id="message-input">
            <button class="btn-emoji">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8zm3.5-9c.828 0 1.5-.672 1.5-1.5S16.328 8 15.5 8 14 8.672 14 9.5s.672 1.5 1.5 1.5zm-7 0c.828 0 1.5-.672 1.5-1.5S9.328 8 8.5 8 7 8.672 7 9.5 7.672 11 8.5 11zm3.5 6.5c2.33 0 4.32-1.458 5.11-3.5H6.89c.79 2.042 2.78 3.5 5.11 3.5z" fill="currentColor"/>
                </svg>
            </button>
            <div class="emoji-picker"></div>
        </div>
        <button class="btn-send" id="send-message">
            <svg viewBox="0 0 24 24" width="20" height="20">
                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" fill="currentColor"/>
            </svg>
        </button>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const CURRENT_USER = 'CopGit918';
    const CURRENT_DATETIME = '2025-03-31 19:00:53';

    let currentConversationId = null;
    let lastMessageTime = null;
    let pollingInterval = null;
    let displayedMessages = new Set();
    let isMinimized = false;
    let currentUsername = '';

    const chatDialog = document.getElementById('chat-dialog');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-message');
    const messagesContainer = document.querySelector('.chat-messages');
    const minimizeButton = document.querySelector('.minimize-chat');
    const chatHeader = document.querySelector('.chat-header');
    const emojiButton = document.querySelector('.btn-emoji');
    const emojiPicker = document.querySelector('.emoji-picker');
    const emojis = [
        'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä',
        'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò',
        'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™',
        'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè', 'üòí',
        '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'ü§é', 'üñ§',
        'üëç', 'üëé', 'üëè', 'üôå', 'ü§ù', 'ü§ó', 'ü§î', 'ü§≠'
    ];
    function initEmojiPicker() {
        emojis.forEach(emoji => {
            const span = document.createElement('span');
            span.className = 'emoji-item';
            span.textContent = emoji;
            span.addEventListener('click', () => {
                messageInput.value += emoji;
                messageInput.focus();
                toggleEmojiPicker();
                sendButton.style.opacity = '1';
            });
            emojiPicker.appendChild(span);
        });
    }

    // G√©rer l'affichage du s√©lecteur d'emoji
    function toggleEmojiPicker() {
        emojiPicker.classList.toggle('active');
    }

    // Fermer le s√©lecteur d'emoji lors d'un clic √† l'ext√©rieur
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.btn-emoji') && !e.target.closest('.emoji-picker')) {
            emojiPicker.classList.remove('active');
        }
    });

    // Ajouter l'√©couteur d'√©v√©nements pour le bouton emoji
    emojiButton.addEventListener('click', (e) => {
        e.preventDefault();
        toggleEmojiPicker();
    });

    // Initialiser le s√©lecteur d'emoji
    initEmojiPicker();


    function getCsrfToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]').value;
    }

    function getInitialColor(username) {
        return username.charAt(0).toUpperCase() === 'T' ? '#0084ff' : '#65676b';
    }

    function formatTime(dateString) {
        const date = new Date(dateString);
        return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
    }

    function toggleMinimize(event) {
    if(event) {
        event.stopPropagation();
    }
    isMinimized = !isMinimized;
    chatDialog.classList.toggle('minimized', isMinimized);
    
    if (isMinimized) {
        // Supprimer l'ancien nom s'il existe
        const oldUsername = chatDialog.querySelector('.minimized-username');
        if (oldUsername) oldUsername.remove();
        
        // Cr√©er le nouvel √©l√©ment pour le nom
        const usernameDiv = document.createElement('div');
        usernameDiv.className = 'minimized-username';
        usernameDiv.textContent = currentUsername;
        chatDialog.appendChild(usernameDiv);
    } else {
        const usernameDiv = chatDialog.querySelector('.minimized-username');
        if (usernameDiv) usernameDiv.remove();
    }
}

    chatHeader.addEventListener('click', function(e) {
        if (isMinimized && !e.target.closest('.close-chat')) {
            toggleMinimize();
        }
    });

    minimizeButton.addEventListener('click', toggleMinimize);

    document.querySelectorAll('.btn-message').forEach(button => {
        button.addEventListener('click', async function() {
            const userId = this.dataset.userId;
            const username = this.dataset.username;
            currentUsername = username;
            const initialColor = getInitialColor(username);

            chatDialog.style.display = 'block';
            isMinimized = false;
            chatDialog.classList.remove('minimized');

            const headerInfo = document.querySelector('.chat-header-info');
            headerInfo.querySelector('.header-initial').textContent = username.charAt(0);
            headerInfo.querySelector('.header-initial').style.backgroundColor = initialColor;
            headerInfo.querySelector('.chat-title').textContent = username;

            try {
                displayedMessages.clear();
                messagesContainer.innerHTML = '';
                await loadConversation(userId);
            } catch (error) {
                console.error('Error:', error);
                alert('Erreur lors du chargement de la conversation');
            }
        });
    });

    async function loadConversation(userId) {
    const response = await fetch(`/utilisateurs/conversations/${userId}/`);
    if (!response.ok) throw new Error('Network response was not ok');

    const data = await response.json();
    currentConversationId = data.conversation_id;

    // R√©initialiser l'√©tat
    displayedMessages.clear();
    messagesContainer.innerHTML = '';

    // Afficher les messages existants s'il y en a
    if (data.messages && data.messages.length > 0) {
        data.messages.forEach(message => {
            displayMessage(message);
        });
        // Mettre √† jour lastMessageTime avec le dernier message
        lastMessageTime = data.messages[data.messages.length - 1].horodatage;
    } else {
        // Si pas de messages, initialiser avec la date actuelle
        lastMessageTime = new Date().toISOString();
    }

    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // R√©initialiser le polling
    if (pollingInterval) clearInterval(pollingInterval);
    pollingInterval = setInterval(checkNewMessages, 3000);
}

    async function checkNewMessages() {
        if (!currentConversationId || !lastMessageTime) return;

        try {
            const response = await fetch(`/utilisateurs/conversations/${currentConversationId}/new-messages/${encodeURIComponent(lastMessageTime)}/`);
            if (!response.ok) throw new Error('Network response was not ok');

            const data = await response.json();
            data.messages.forEach(message => {
                const messageKey = `${message.expediteur}-${message.horodatage}-${message.contenu}`;
                if (!displayedMessages.has(messageKey)) {
                    displayMessage(message);
                    displayedMessages.add(messageKey);
                    lastMessageTime = message.horodatage;

                    // Mettre √† jour le dernier message dans la liste des utilisateurs
                    if (data.other_user_id && data.last_message) {
                        const userCard = document.querySelector(`.user-card[data-user-id="${data.other_user_id}"]`);
                        if (userCard) {
                            const lastMessageSpan = userCard.querySelector('.last-message');
                            if (lastMessageSpan) {
                                lastMessageSpan.textContent = data.last_message;
                            }
                            // D√©placer la carte en haut de la liste
                            const userList = userCard.parentElement;
                            userList.insertBefore(userCard, userList.firstChild);
                        }
                    }

                    if (!isMinimized) {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }
                }
            });
        } catch (error) {
            console.error('Error:', error);
        }
    }

    async function updateLastMessage(userId, messageContent) {
        const userCard = document.querySelector(`.user-card[data-user-id="${userId}"]`);
        if (userCard) {
            const lastMessageSpan = userCard.querySelector('.last-message');
            if (lastMessageSpan) {
                lastMessageSpan.textContent = messageContent;
            }
        }
    }

    async function sendMessage() {
        const content = messageInput.value.trim();
        if (!content || !currentConversationId) return;

        try {
            const formData = new FormData();
            formData.append('conversation_id', currentConversationId);
            formData.append('message', content);

            const response = await fetch('/utilisateurs/send-message/', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                }
            });

            if (!response.ok) throw new Error('Network response was not ok');

            const data = await response.json();
            if (data.status === 'success') {
                displayMessage(data.message);
                messageInput.value = '';
                if (!isMinimized) {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
                sendButton.style.opacity = '0.7';
                
                // Forcer le rafra√Æchissement des derniers messages
                await refreshLastMessages();
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Erreur lors de l\'envoi du message');
        }
    }

    function displayMessage(message) {
        const messageKey = `${message.expediteur}-${message.horodatage}-${message.contenu}`;
        if (displayedMessages.has(messageKey)) return;

        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', message.is_mine ? 'sent' : 'received');

        if (!message.is_mine) {
            const initialDiv = document.createElement('div');
            initialDiv.classList.add('user-initial', 'message-initial');
            initialDiv.style.backgroundColor = getInitialColor(message.expediteur);
            initialDiv.textContent = message.expediteur.charAt(0);
            messageDiv.appendChild(initialDiv);
        }

        const bubbleDiv = document.createElement('div');
        bubbleDiv.classList.add('message-bubble');
        bubbleDiv.innerHTML = `
            <div class="message-content">${message.contenu}</div>
        `;
        messageDiv.appendChild(bubbleDiv);

        const timeDiv = document.createElement('div');
        timeDiv.classList.add('message-time');
        timeDiv.textContent = formatTime(message.horodatage);
        messageDiv.appendChild(timeDiv);

        messagesContainer.appendChild(messageDiv);
        displayedMessages.add(messageKey);
        lastMessageTime = message.horodatage;
    }

    function closeChat() {
        chatDialog.style.display = 'none';
        currentConversationId = null;
        lastMessageTime = null;
        displayedMessages.clear();
        isMinimized = false;
        chatDialog.classList.remove('minimized');
        currentUsername = '';
        if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
        }
    }

    document.querySelector('.close-chat').addEventListener('click', closeChat);
    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendMessage();
    });

    messageInput.addEventListener('input', function() {
        sendButton.style.opacity = this.value.trim() ? '1' : '0.7';
    });

    // Ajouter une fonction pour mettre √† jour p√©riodiquement tous les derniers messages
    function updateAllLastMessages() {
        fetch('/utilisateurs/get_all_last_messages/')
            .then(response => response.json())
            .then(data => {
                data.last_messages.forEach(msg => {
                    const userCard = document.querySelector(`.user-card[data-user-id="${msg.user_id}"]`);
                    if (userCard) {
                        const lastMessageSpan = userCard.querySelector('.last-message');
                        if (lastMessageSpan) {
                            lastMessageSpan.textContent = msg.content;
                            
                            // D√©placer la carte au d√©but si c'est le message le plus r√©cent
                            if (msg.is_most_recent) {
                                const userList = userCard.parentElement;
                                userList.insertBefore(userCard, userList.firstChild);
                            }
                        }
                    }
                });
            })
            .catch(error => console.error('Error:', error));
    }

    // Mettre √† jour les derniers messages toutes les 3 secondes
    setInterval(updateAllLastMessages, 3000);

    // Ajouter cette fonction pour mettre √† jour la liste des messages
    async function refreshLastMessages() {
        try {
            const response = await fetch('/utilisateurs/get_all_last_messages/');
            const data = await response.json();
            
            data.last_messages.forEach(msg => {
                const messagePreview = document.querySelector(`.user-card[data-user-id="${msg.user_id}"] .message-preview`);
                if (messagePreview) {
                    // Vider le contenu existant
                    messagePreview.innerHTML = '';
                    
                    // Ajouter "Vous : " si c'est votre message
                    if (msg.is_mine) {
                        const senderSpan = document.createElement('span');
                        senderSpan.className = 'message-sender';
                        senderSpan.textContent = 'Vous : ';
                        messagePreview.appendChild(senderSpan);
                    }
                    
                    // Ajouter le message
                    const messageSpan = document.createElement('span');
                    messageSpan.className = 'last-message';
                    if (!msg.is_mine && !msg.is_read) {
                        messageSpan.classList.add('unread');
                    }
                    messageSpan.textContent = msg.content;
                    messagePreview.appendChild(messageSpan);
                    
                    // D√©placer la carte si c'est le message le plus r√©cent
                    if (msg.is_most_recent) {
                        const userCard = messagePreview.closest('.user-card');
                        const userList = document.getElementById('user-list');
                        userList.insertBefore(userCard, userList.firstChild);
                    }
                }
            });
        } catch (error) {
            console.error('Error refreshing messages:', error);
        }
    }

    // Mettre √† jour les messages toutes les 3 secondes
    setInterval(refreshLastMessages, 3000);
});
</script>
{% endblock %}